## ADR-001: Архітектурний стиль

## Статус
Прийнято (2025-10-01)

## Контекст

- Команда з 4 розробники без спонсорства, що має обмежений строк для реалізації проекту (3-4 місяці)

- Усі функціональні вимоги (FR): [requirements.md](docs/requirements/requirements.md)

- Усі нефункціональні вимоги (NFR): [requirements.md](docs/requirements/requirements.md)
  
## Рішення
Використовувати гібридну архітектуру, а саме поєднання клієнт-сервісної з Firebase (Auth, Firestore, </br>
Realtime DB, Storage, FCM) та Custom Backend (Node.js) для складної бізнес-логіки, платежів та аналітики.

## Наслідки - Переваги рішення </br>

✅ **Firebase покриває 60% функціоналу out-of-the-box:**
  - Authentication (FR-001) — готове рішення
  - Realtime Database (FR-013) — синхронізація ≤2с без коду
  - Firestore (FR-002, FR-016) — offline-first за замовчуванням
  - Storage (FR-013) — медіа для тренувань
  - FCM (FR-010) — push-сповіщення без сервера
  
✅ **Custom Backend тільки для складної логіки (40%):**
  - ML/адаптація тренувань (FR-014, FR-012, FR-005, FR-011)

✅ **Швидкість розробки MVP:**
  - Не потрібно писати auth/storage/notifications
  - Фокус на бізнес-логіці

✅ **Масштабованість:**
  - Firebase автоматично масштабується (до 1M користувачів безпроблемно)
  - Backend масштабується окремо (горизонтально)

✅ **Надійність:**
  - Firebase SLA: 99.95% (краще за REL-001: 99.0%)
  - Вбудовані backups та disaster recovery

✅ **Вартість:**
  - Firebase Free Tier достатньо для тестування
  - Pay-as-you-go для production
  - Backend тільки для складної логіки = менші витрати
    
## Наслідки - Недоліки рішення </br>

⚠️ **Vendor lock-in Firebase:**
  - Міграція можлива, але потребує зусиль
  - **Обраний спосіб вирішення проблеми.** Використання репозиторій-паттерну в Flutter, абстракція </br> Firebase за інтерфейсами

⚠️ **Дві точки відмови:**
  - Firebase може впасти (рідко, але можливо)
  - Backend може впасти
  - **Обраний спосіб вирішення проблеми.** Firebase має 99.95% SLA, Backend робимо stateless для </br>  швидкого відновлення

⚠️ **Складність синхронізації:**
  - Клієнт іноді йде до Firebase, іноді до Backend
  - **Обраний спосіб вирішення проблеми.** Чіткі правила в документації (коли що використовувати)

## Розглянуті альтернативи

- Monolithic Layered (відхилено) </br>
❌ Реалізація усіх сервісів власноруч </br>
❌ Низька швидкість реалізації проекту  </br>

- Microservices (відхилено) </br>

  - Переваги</br>
  ✅ Незалежне масштабування кожного сервісу </br>
  ✅ Технологічна різноманітність (Node.js + Python) </br>
  ✅ Ізоляція збоїв </br>
  ✅ Команди можуть працювати паралельно </br>
  - Недоліки</br>
  ❌ Надмірна складність для команди з 4 осіб </br>
  ❌ Потрібен API Gateway (додатковий overhead) </br>
  ❌ Складність налагодження розподілених систем </br>
  ❌ Управління міжсервісною комунікацією </br>
  ❌ DevOps складність (Kubernetes/Docker orchestration) </br>
  ❌ Overhead на розробку інфраструктури замість features </br>
  ❌ Дублювання коду (auth, logging, monitoring в кожному сервісі) </br>


- Pure Firebase без Custom Backend (відхилено) </br>

  ❌ Cloud Functions не підходять для ML/адаптації тренувань </br>
  ❌ Складні транзакції (платежі) важко налагоджувати </br>
  ❌ Обмежені можливості для складних запитів та агрегацій </br>

