# Детальне обґрунтування вибору архітектурного стилю

## Контекст прийняття рішення

### Вихідні дані проєкту

**Команда:**
- 4 розробники (Backend/Frontend досвід)
- Досвід з Flutter та Firebase
- Обмежені ресурси для MVP (5-10 годин/тиждень на людину)

**Технологічний стек (вже обрано):**
- **Frontend:** Flutter (iOS + Android)
- **Database/Auth:** Firebase (Firestore, Realtime DB, Auth)
- **Backend:** (TBD)

**Бізнес-вимоги:**
- Швидкий вихід на ринок (3-4 місяці до MVP)
- Підтримка offline-режиму для критичного функціоналу
- Realtime синхронізація workout sessions
- Складна бізнес-логіка (адаптивні тренування, платежі, аналітика)

**Нефункціональні вимоги:**
- REL-001: 99.0% uptime
- PERF-001: Відповідь ≤1с для локальних операцій
- REL-004: Синхронізація ≤2с між пристроями
- SEC-004: PCI DSS compliance для платежів

---

## Аналіз можливих архітектурних стилів

### 1. Microservices Architecture

#### Опис
Розбиття backend на незалежні мікросервіси:
```
Flutter Client
    ↓
API Gateway
    ↓
├── Auth Service (Node.js)
├── Workout Service (Python)
├── Payment Service (Node.js)
├── Analytics Service (Python)
├── Notification Service (Node.js)
└── User Service (Node.js)
```

#### Переваги
- ✅ Незалежне масштабування кожного сервісу
- ✅ Технологічна різноманітність (Node.js + Python)
- ✅ Ізоляція збоїв
- ✅ Команди можуть працювати паралельно

#### Недоліки
- ❌ **Надмірна складність для команди з 4 осіб**
- ❌ Потрібен API Gateway (додатковий overhead)
- ❌ Складність налагодження розподілених систем
- ❌ Управління міжсервісною комунікацією
- ❌ DevOps складність (Kubernetes/Docker orchestration)
- ❌ Overhead на розробку інфраструктури замість features
- ❌ Дублювання коду (auth, logging, monitoring в кожному сервісі)

#### Висновок
❌ **Не підходить** — premature optimization. Мікросервіси потрібні при > 10 розробників та > 100K користувачів. Для MVP це overengineering.

---

### 2. Event-Driven Architecture

#### Опис
Архітектура на основі подій з брокером повідомлень:
```
Flutter Client
    ↓
Backend Services
    ↓
Message Broker (RabbitMQ/Kafka)
    ↓
Event Consumers (Workers)
```

#### Переваги
- ✅ Асинхронна обробка
- ✅ Слабка зв'язаність компонентів
- ✅ Легко додавати нові consumers
- ✅ Підходить для складних workflow

#### Недоліки
- ❌ **Складність налагодження** (події важко трасувати)
- ❌ Кінцева узгодженість (eventual consistency)
- ❌ Потрібна інфраструктура для брокера повідомлень
- ❌ Складність тестування
- ❌ Overkill для більшості CRUD операцій Wellity
- ❌ Навчання команди новій парадигмі

#### Висновок
❌ **Не підходить** — event-driven має сенс для систем з складними асинхронними workflow (IoT, фінанси). Для Wellity більшість операцій синхронні (CRUD + realtime).

---

### 3. Client-Server with Firebase (BaaS) + Custom Backend

#### Опис
Гібридна архітектура з розподілом відповідальностей:
```
Flutter Client (Clean Architecture + BLoC)
    ↓ (direct)              ↓ (REST API)
Firebase (BaaS)         Custom Backend (Node.js)
- Auth                  - Adaptive Logic
- Firestore             - Payments
- Realtime DB           - Analytics
- Storage               - Verification
- FCM                   - Complex Queries
```

#### Переваги
- ✅ **Firebase покриває 60% функціоналу out-of-the-box:**
  - Authentication (FR-001) — готове рішення
  - Realtime Database (FR-013) — синхронізація ≤2с без коду
  - Firestore (FR-002, FR-016) — offline-first за замовчуванням
  - Storage (FR-013) — медіа для тренувань
  - FCM (FR-010) — push-сповіщення без сервера
  
- ✅ **Custom Backend тільки для складної логіки (40%):**
  - ML/адаптація тренувань (FR-014)
  - Payment processing (FR-012)
  - Складні агрегації для тренерів (FR-005)
  - Верифікація (FR-011)

- ✅ **Швидкість розробки MVP:**
  - Команда вже знає Firebase
  - Не потрібно писати auth/storage/notifications
  - Фокус на бізнес-логіці

- ✅ **Масштабованість:**
  - Firebase автоматично масштабується (до 1M користувачів безпроблемно)
  - Backend масштабується окремо (горизонтально)

- ✅ **Надійність:**
  - Firebase SLA: 99.95% (краще за REL-001: 99.0%)
  - Вбудовані backups та disaster recovery

- ✅ **Вартість:**
  - Firebase Free Tier достатньо для тестування
  - Pay-as-you-go для production
  - Backend тільки для складної логіки = менші витрати

#### Недоліки
- ⚠️ **Vendor lock-in Firebase:**
  - Міграція можлива, але потребує зусиль
  - **Мітігація:** Використання репозиторій-паттерну в Flutter, абстракція Firebase за інтерфейсами

- ⚠️ **Дві точки відмови:**
  - Firebase може впасти (рідко, але можливо)
  - Backend може впасти
  - **Мітігація:** Firebase має 99.95% SLA, Backend робимо stateless для швидкого відновлення

- ⚠️ **Складність синхронізації:**
  - Клієнт іноді йде до Firebase, іноді до Backend
  - **Мітігація:** Чіткі правила в документації (коли що використовувати)

#### Висновок
✅ **ОБРАНО** — оптимальний баланс між швидкістю розробки, надійністю та масштабованістю.

---

## Розподіл відповідальностей: Firebase vs Backend

### Правило розподілу

**Firebase використовується для:**
1. ✅ CRUD операцій (створити/читати/оновити/видалити)
2. ✅ Realtime синхронізації
3. ✅ Автентифікації
4. ✅ Файлового сховища

**Backend використовується для:**
1. ✅ Складних розрахунків (ML/адаптація тренувань)
2. ✅ Інтеграцій зі сторонніми API (Stripe, PayPal)
3. ✅ Складних запитів з агрегаціями
4. ✅ Бізнес-логіки, яку важко реалізувати у Firebase Rules
5. ✅ Push-сповіщень

## Компроміси та прийняті рішення

### Компроміс 1: Vendor Lock-in Firebase

**Проблема:** Повна залежність від Google Firebase

**Прийняте рішення:** Приймаємо lock-in для MVP

**Обґрунтування:**
- Міграція можлива через репозиторій-паттерн у Flutter
- Альтернативи (AWS Amplify, Supabase) мають схожі проблеми
- Вигода від швидкості розробки перевищує ризик
- Netflix, Spotify, Duolingo успішно працюють на Firebase

**План мітігації:**
- Використання інтерфейсів замість прямих викликів Firebase
- Документування всіх Firebase-специфічних рішень
- При досягненні 500K користувачів — розглянути міграцію

### Компроміс 2: Дві точки відмови

**Проблема:** Firebase і Backend можуть впасти незалежно

**Прийняте рішення:** Приймаємо, але мінімізуємо ризики

**Обґрунтування:**
- Firebase має 99.95% SLA (краще за нашу вимогу 99.0%)
- Backend робимо stateless для швидкого автоматичного відновлення
- Критичні операції (habit trackers) працюють offline

**План мітігації:**
- Monitoring (Sentry для Backend, Firebase Crashlytics)
- Health checks кожні 30 секунд
- Automatic restarts для Backend containers
- Graceful degradation: якщо Backend недоступний, Firebase функції продовжують працювати

### Компроміс 3: Складність архітектури для junior розробників

**Проблема:** Потрібно розуміти коли йти до Firebase, коли до Backend

**Прийняте рішення:** Створюємо чіткі guidelines

**Обґрунтування:**
- Альтернатива (все через Backend) повільніша та дорожча
- Альтернатива (все через Firebase) неможлива для ML/payments

**План мітігації:**
- Документувати правила у `docs/architecture/data-flow-rules.md`
- Code review перевіряє дотримання правил
- Onboarding guide для нових розробників

---

## Підсумок: Чому Client-Server?

### Технічні причини
1. **Firebase вже обрано** — не використовувати його нераціонально
2. **60% функціоналу Firebase покриває безкоштовно** (auth, storage, realtime)
3. **40% складної логіки** потребує Custom Backend
4. **Швидкість розробки MVP** — найвищий пріоритет

### Бізнес-причини
1. **Час виходу на ринок:** 3-4 місяці (vs 6-9 для мікросервісів)
2. **Вартість розробки:** $0 інфраструктура для старту
3. **Розмір команди:** 4 особи (vs 8-12 для мікросервісів)
4. **Ризик overengineering:** низький

### Довгострокова перспектива
- Архітектура може еволюціонувати до мікросервісів
- Firebase залишається для auth/storage/realtime
- Backend поступово розбивається на сервіси
- **Шлях еволюції чіткий та передбачуваний**

---

**Кінцеве рішення:** Client-Server Architecture з Firebase (BaaS) + Custom Backend є оптимальним вибором для Wellity, що забезпечує баланс між швидкістю розробки, технічною досконалістю та можливістю еволюції.